# Lab 6: Monte Carlo Methods (5 points)

**Deadline**: Tuesday, May 21, 2024 at 11:59pm on Gradescope

## Installations

Ensure you have the following modules installed on your system:

* Numpy
* Matplotlib

You can install these modules using pip:

```bash
pip install numpy matplotlib
```

## Part 1: Estimating $\pi$ using Simple Monte Carlo Methods [2 points]

This part involves using the Monte Carlo method to estimate the value of $\pi$. You will simulate random point placements within a square to determine how many points fall inside a unit circle inscribed in the square. This method leverages probability and the geometric properties of the circle and the square to approximate the value of Ï€.

Note that the area of a unit circle is $\pi \times 1^2 = \pi$. This unit circle is inscribed in a square with side length 2, so the area of the square is $2^2 = 4$. The ratio of the area of the circle to the area of the square is $\frac{\pi}{4}$. Therefore, the probability of a point falling inside the circle is $\frac{\pi}{4}$.

You are provided with a function template called `estimate_pi(num_samples, step)`. This function should simulate the placement of `num_samples` random points within a unit square and determine how many fall inside the inscribed unit circle.

**Tasks:**

* Implement the Monte Carlo logic inside the `estimate_pi` function to estimate $\pi$.
* Collect data periodically (as specified by the step parameter) for visualization purposes. This data should include:
  * Coordinates of points inside the circle.
  * Coordinates of points outside the circle.
  * The current estimate of $\pi$.

After implementing the functions, test your simulation with different numbers of samples and steps. Observe the accuracy and variability of your $\pi$ estimates over time.

The resulting visualization should be saved as a GIF file named `monte_carlo_pi.gif`. The GIF should show the progression of the Monte Carlo simulation over time with the estimated value of $\pi$ displayed on each frame. If you implemented it correctly, the estimated value of $\pi$ should converge to the actual value of $\pi = 3.14159...$ as the number of samples increases.

## Part 2: Solving a Maze using Monte Carlo Methods [3 points]

In this part, you will work on simulating and visualizing a pathfinding problem in a maze. You'll generate a maze grid with obstacles, and then use Monte Carlo simulations to find a feasible path from the start to the goal of the maze.

The code provided in `mc_grid.py` contains all the code for this part.

**Tasks:**

* Implement the `is_valid_move` function to check if a proposed move within the maze is valid (i.e., within bounds and not into an obstacle). Return `True` if the move is valid, and `False` otherwise.
* Develop the `find_path` function using a **Monte Carlo method** to simulate multiple random paths from the start to the goal. Keep track of the best path found during the simulations.

**Note**: You may use any Monte Carlo method discussed in class or from the textbook, but it must be a Monte Carlo method and not any general pathfinding algorithm (like A* or Dijkstra's).

Once you run the `mc_grid.py` script, it should generate a visualization of the maze with the best path found by the Monte Carlo simulation. The visualization should be saved as a PNG file named `maze_path.png`.

You may notice that sometimes there is no path found by the Monte Carlo simulation because no path exists (for example, if the goal is completely blocked by obstacles). In such cases, you can re-run the script to generate a new maze and try again.

The code contains two parameters, `size` and `obstacle_rate`, that you can adjust to generate different maze configurations. The `size` parameter determines the dimensions of the maze grid, while the `obstacle_rate` parameter controls the density of obstacles in the maze. Feel free to experiment with different values for these parameters to see how they affect the maze generation and pathfinding.

Once you are confident that your code works, I suggest you try using a large maze (e.g. 50x50) to run your code. How long does it take? Think about how the runtime compares to the A* algorithm that you implemented in a previous lab.

## Submission

Once you're done with the assignment, submit the following files to Gradescope:

1. `estimate_pi.py`
2. `mc_grid.py`
3. `monte_carlo_pi.gif`
4. `maze_path.png`

The `monte_carlo_pi.gif` and `maze_path.png` files should be generated by running the provided `estimate_pi.py` and `mc_grid.py` scripts, respectively.

Make sure to save your Python files before uploading them. You can submit as many times as you like before the deadline. Only the last submission will be graded.