import numpy as np
import matplotlib.pyplot as plt
import random
from matplotlib.colors import BoundaryNorm

def generate_maze(size=10, obstacle_rate=0.3):
    """
    Generate a maze grid with obstacles where the start and goal positions are fixed.

    Parameters:
        size (int): The size of the maze (size x size).
        obstacle_rate (float): The probability of an obstacle being placed in a cell.

    Returns:
        np.array: The maze grid with cells marked as start (1), goal (2), open (0), and obstacle (-1).
    """
    maze = np.zeros((size, size), dtype=int)
    
    for i in range(size):
        for j in range(size):
            if random.random() < obstacle_rate and (i != 0 or j != 0) and (i != size - 1 or j != size - 1):
                maze[i, j] = -1  # Obstacle
            else:
                maze[i, j] = 0  # Open cell

    maze[0, 0] = 1  # Start
    maze[size-1, size-1] = 2  # Goal
    return maze

def plot_maze(maze):
    """
    Plot the maze with different colors indicating obstacles, start, and goal.

    Parameters:
        maze (np.array): The maze grid generated by `generate_maze`.
    
    """
    cmap = plt.cm.viridis
    cmap.set_under('black')  # Obstacles as black
    cmap.set_over('gold')  # Goal as gold
    bounds = [-1, 0, 1, 2, 3]
    norm = BoundaryNorm(bounds, cmap.N, clip=False, extend='both')
    
    fig, ax = plt.subplots(figsize=(8, 8))
    cax = ax.matshow(maze, cmap=cmap, norm=norm)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.plot(0, 0, "o", label="Start", color="red")  # Start
    ax.plot(len(maze)-1, len(maze)-1, "o", label="Goal", color="gold")  # Goal
    plt.legend()
    plt.show()

def is_valid_move(maze, x, y):
    """
    Check if the next move is valid within the maze boundaries and not an obstacle.

    Parameters:
        maze (np.array): The maze grid.
        x (int): X-coordinate of the proposed move.
        y (int): Y-coordinate of the proposed move.

    Returns:
        bool: True if the move is valid, False otherwise.

    TODO:
    - Implement the validation logic for a move.
    """
    
    return ...  # Add your code here

def find_path(maze, num_simulations=1000):
    """
    Use Monte Carlo simulation to find a feasible path from start to goal in the maze.

    Parameters:
        maze (np.array): The maze grid.
        num_simulations (int): Number of simulation runs to attempt finding a path.

    Returns:
        list: Coordinates of the best path found or None if no path is found.

    TODO:
    - Implement a Monte Carlo simulation to generate paths and select the best one.
    """
    size = maze.shape[0]
    best_path = None

    # Add your code here

    return best_path

def plot_best_path(maze, path):
    """
    Plot the best path found by `find_path` over the maze.

    Parameters:
        maze (np.array): The maze grid.
        path (list): List of coordinates representing the best path found.

    - Implement plotting logic for the best path on the maze grid.
    """
    fig, ax = plt.subplots(figsize=(8, 8))
    cax = ax.matshow(maze, cmap=plt.cm.viridis, vmin=-1.5, vmax=2.5)
    if path:
        x, y = zip(*path)
        ax.plot(y, x, color="red", linewidth=2, marker='o')  # Plot path
    ax.set_xticks([])
    ax.set_yticks([])
    plt.savefig("maze_path.png")
    plt.show()

# Parameters for simulation
size = 15
obstacle_rate = 0.2

# Generate and visualize the maze
maze = generate_maze(size, obstacle_rate)
plot_maze(maze)

# Find and visualize the best path
path = find_path(maze, num_simulations=1000)
plot_best_path(maze, path if path else [])
